<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>NodeXT &mdash; Plugin-driven Node.js applications</title>
        <link rel="stylesheet" href="css/nodext.css" />
    </head>
    <body prefix="doap: http://usefulinc.com/ns/doap#" about="http://bergie.github.com/nodext/" typeof="doap:Project">
        <header>
            <a href="https://github.com/bergie/nodext" rel="doap:homepage"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://d3nwyuy0nl342s.cloudfront.net/img/71eeaab9d563c2b3c590319b398dd35683265e85/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub"></a>
        </header>
        <article>
            <h1 class="editable"><span property="doap:name">NodeXT</span> &mdash; <span property="doap:shortdesc">Plugin-driven Node.js applications</span></h1>

            <div property="doap:description" class="editable">
<p>NodeXT is a way to organize your Node.js web application so that it is driven by a collection of extensions. This makes the application easier to manage, as distinct collections of functionality can be isolated in their own extensions that can be enabled and disabled as needed.</p>

            <nav>
                <ul>
                    <li><a href="/api/">API documentation</a></li>
                    <li><a href="https://github.com/bergie/nodext">Source code</a></li>
                    <li><a href="http://search.npmjs.org/#/nodext">NPM package</a></li>
                </ul>
            </nav>

<p>Each extension runs within a URL prefix provided by configuration.</p>

<h2>Structure of an extension</h2>

<p>At minimum, an extension provides a <code>main</code> file that exports method <code>extension</code>. This method returns a constructor function to the extension object.</p>

<p>The NodeXT extension loader calls this method for each enabled extension, and then instantiates the extension objects through the constructor functions.</p>

<p>These constructor functions get a configuration object that may contain extension-specific configurations.</p>

<p>The  extension might look like the following (in CoffeeScript):</p>

<pre><code># Get the extension base class
nodext = require 'nodext'

class MyExtension extends nodext.Extension
  name: "MyExtension"
  config: {}

exports.extension = MyExtension
</code></pre>

<p>There are several methods that the extensions may implement to provide actual behavior:</p>

<ul>
<li>
<code>configure(server)</code>: run in the configuration phase of Express. An extension could add its own middlewares to server configuration here, for example to provide static servers or authentication</li>
<li>
<code>getModels(schema, otherModels)</code>: run whenever JugglingDB is used. Here the extension can provide its own JugglingDB models if necessary</li>
<li>
<code>registerRoutes(server)</code> run after server has been configured. Here the extension can register its own Express routes</li>
</ul><p>The extension configuration contains a key <code>urlPrefix</code> that tells the URL prefix the extension should run under. A well-behaved component should only register middleware or routes to work under the prefix to ensure it doesn't step on the toes of other loaded extensions.</p>

<p>For example:</p>

<pre><code>nodext = require 'nodext'
express = require 'express'

class MyExtension extends nodext.Extension
  name: "MyExtension"
  config: {}

  configure: (server) -&gt;
    # Function to check authentication against the username
    # and password provided in extension configuration
    checkAuth = (username, password) =&gt;
      if username is @config.username and password is @config.password
        return true
        false

    # Use HTTP Basic authentication under the URL space handled
    # by this extension
    server.use @config.urlPrefix, express.basicAuth checkAuth

  registerRoutes: (server) -&gt;
    # Register a route under the URL space handled by this
    # extension
    server.get "#{@config.urlPrefix}hello/:user", (req, res) -&gt;
      res.send "Hello #{req.params.user}"

exports.extension = MyExtension
</code></pre>

<h3>Configuring and running extensions</h3>

<p>Such extension, stored in <code>extension/my/main.coffee</code> could be enabled by:</p>

<pre><code>{
  "server": {
    "hostname": "127.0.0.1",
    "port": 8001
  },
  "extensions": {
    "/foo/": {
      "name": "my",
      "location": "./extension/my",
      "configuration": {
        "username": "user",
        "password": "pass"
      }
    }
  }
}
</code></pre>

<p>Now, run this with NodeXT:</p>

<pre><code>$ nodext my_config_file.json
</code></pre>

<p>...and the extension's route should answer in <a href="http://127.0.0.1/foo/hello/World">http://127.0.0.1/foo/hello/World</a>. Use <em>user</em> / <em>pass</em> to log in.</p>

<h4>Extensions from NPM packages</h4>

<p><a href="http://npmjs.org/">NPM</a> packages may also contain extensions. For example, to use the <a href="https://github.com/bergie/nodext-create">nodext-create</a> extension, install it with:</p>

<pre><code>$ npm install nodext-create
</code></pre>

<p>And then enable in your configuration with:</p>

<pre><code>"/create/": {
  "name": "create",
  "location": "./node_modules/nodext-create",
  "configuration": {}
}
</code></pre>

<p>If NodeXT takes off, this might be a great way to ship reusable website components like user management, news listings, and others for Node.js web applications.</p>

<h2>Using NodeXT with SSL</h2>

<p>NodeXT can be configured to run with HTTPS quite easily. You'll need the necessary certificate files. To generate simple ones for local testing, run:</p>

<pre><code>$ openssl genrsa -out privatekey.pem 1024 
$ openssl req -new -key privatekey.pem -out certrequest.csr 
$ openssl x509 -req -in certrequest.csr -signkey privatekey.pem -out certificate.pem
</code></pre>

<p>And then just configure your NodeXT server to use them:</p>

<pre><code>  "server": {
    "hostname": "127.0.0.1",
    "port": 443,
    "privateKey": "privatekey.pem",
    "certificate": "certificate.pem"
  },
</code></pre>

<h2>Optional ORM integration</h2>

<p>NodeXT has optional integration with the <a href="https://github.com/1602/jugglingdb#readme">JugglingDB</a> ORM. This allows very easy creation of database-backed Node.js applications.</p>

<p>JugglingDB can persist content in multiple storage back-ends including MySQL, MongoDB and Redis. The JugglingDB connection can be set up in your NodeXT configuration file. Here is an example of using a local Redis service:</p>

<pre><code>"database": {
  "provider": "redis",
  "configuration": {}
},
</code></pre>

<p>And this is how a MySQL connection could be configured:</p>

<pre><code>"database": {
  "provider": "mysql",
  "configuration": {
    "username": "someuser",
    "password": "somepassword",
    "database": "dbname"
  }
},
</code></pre>

<h3>Registering models</h3>

<p>Any extension can register JugglingDB models in the <code>getModels</code> method. For example:</p>

<pre><code>class MyExtension extends nodext.Extension
  name: "MyExtension"
  config: {}
  models: {}
  schema: {}

  getModels: (@schema, otherModels) -&gt;
    {Schema} = require 'jugglingdb'
    @models.Post = schema.define 'Post',
      title:
        type: String
        length: 255
        index: true
      content:
        type: Schema.Text
      published_at:
        type: Date
    @models
</code></pre>

<p>This way the extension itself keeps track of the models it registers, so they can later be used in routes, but at the same time they are registered with NodeXT so that it can centrally handle configuration and storage creation.</p>

<h3>Using models and views</h3>

<p>Now the routes will have full JugglingDB access. For example:</p>

<pre><code>  registerRoutes: (server) -&gt;
    # The root route of this component serves a list of
    # posts
    server.get "#{@config.urlPrefix}", (req, res) -&gt;

      # Use the extension's views directory
      server.set 'views', "#{__dirname}/views"

      # Fetch all Post entries and display them
      @models.Post.all (err, posts) -&gt;
        res.render "posts",
          locals:
            items: posts
            as: 'post'
</code></pre>

<h4>Semi-automatic CRUD with Resource-Juggling</h4>

<p><a href="http://search.npmjs.org/#/resource-juggling">Resource-Juggling</a> is a useful library for generating CRUD routes for JugglingDB models and can also be used with NodeXT. Example:</p>

<pre><code>  registerRoutes: (server) -&gt;    
    resource = require 'express-resource'
    resourceJuggling = require 'resource-juggling'

    posts = server.resource resourceJuggling.getResource
      schema: @schema
      name: 'Post'
      model: @models.Post
      base: @config.urlPrefix
</code></pre>

<p>This would create all the necessary routes for Create, Read, Update, and Delete for the model. See <a href="https://github.com/bergie/resource-juggling#readme">Resource-Juggling documentation</a> for more information.</p>

<h3>Creating storage</h3>

<p>With MySQL you need to create the storage tables before using them. With NodeXT you can use the <code>nodext_storage_create</code> command (<strong>note</strong> this will drop any existing data in the JugglingDB database):</p>

<pre><code>$ nodext_storage_create my_config_file.json
</code></pre>

<p>Running this command with the other JugglingDB adapters doesn't have any effect.</p>

<h3>Query logging</h3>

<p>For debugging purposes it is nice to see the database queries executed by JugglingDB. To enable query logging in NodeXT, add the following to the <code>database</code> section of your configuration:</p>

<pre><code>  "logQueries": true
</code></pre>

<p>Depending on your database provider, you should see output like:</p>

<pre><code>SELECT * FROM Post WHERE 1331650495746 
</code></pre>

<p>...or:</p>

<pre><code>KEYS Post:* 1331650628592
</code></pre>
            </div>
        </article>
        <footer prefix="foaf: http://xmlns.com/foaf/0.1/">
            <p>NodeXT is <a href="http://www.opensource.org/licenses/mit-license.php" rel="doap:license">free software</a> developed by <span property="doap:maintainer"><a rel="foaf:homepage" typeof="foaf:Person" href="http://bergie.iki.fi/" property="foaf:name">Henri Bergius</a></span> for <a href="http://nemein.com/">Nemein</a></p>
        </footer>
    </body>
</html>

